#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Date       : 2015-05-26 16:42:13
# Author     : 陈小雪
# E-mail     : shell_chen@yeah.net
# Version    : 1.0.1

import os
import re
import smtplib

from setting import curdir
from mailchecker import MailChecker


class EmailFile(object):

    english_file = os.path.join(curdir, "share/english.txt")
    name_file = os.path.join(curdir, "share/name_1.txt")
    provider_file = os.path.join(curdir, "share/10min_provider.txt")

    def __init__(self):
        self.words = self.loads(self.english_file)
        self.names = self.loads(self.name_file)
        self.providers = self.loads(self.provider_file)

    def loads(self, f):
        words = []
        with open(f) as f:
            for line in f.readlines():
                t = line.strip()
                if not t:
                    continue
                words.append(t)
        return words


class EmailCheks(object):
    email_format_regex = re.compile("""

        #匹配首字符
        ^[A-Za-z0-9]

        #匹配邮箱前缀
        (([_\.\-]?[a-zA-Z0-9_\-]+)*)


        @

        #匹配后缀
        ([A-Za-z0-9]+)(([\.\-]?[a-zA-Z0-9]+)*)\.([A-Za-z]{2,})$
    """, re.X)

    sheng_pin = ['b', 'p', 'm', 'f', 'd', 't', 'n', 'l', 'g', 'k', 'h', 'j', 'q', 'x', 'y',
                 'zh', 'ch', 'sh', 'r', 'z', 'c', 's']

    yun_pin = ['a', 'o', 'e', 'i', 'u', 'ai', 'ei', 'ui', 'ao', 'ou', 'iu', 'ie', 'ue', 'er',
               'an', 'en', 'in', 'un', 'ang', 'eng', 'ing', 'ong']

    def check_word(self, email_prefix):
        for word in self.words:
            if re.search(word.lower(), email_prefix):
                return True

    def check_name(self, email_prefix):
        for name in self.names:
            if re.search(name.lower(), email_prefix):
                return True

    def get_zimu(self, email_prefix):
        """
            声母和韵母的匹配
        """
        sheng = 0
        yun = 0
        for zifu in self.sheng_pin:
            if re.search(zifu, email_prefix):
                sheng += 1

        for zifu in self.yun_pin:
            if re.search(zifu, email_prefix):
                yun += 1
        return sheng, yun

    def check_num(self, email_prefix):  # TODO
        """是否包含常用数字以及生日相关信息"""

        birth = 0
        number = re.search(r'\d+', email_prefix)
        if number:
            num = number.group()
            if re.search(r'520|123456|521|1314|111111|654321', num):
                birth = 1
            for i in xrange(1970, 2015):
                if str(i) in num:
                    birth = 1
            if len(num) == 4:
                month = int(len(num[0:2]))
                day = int(len(num[2:4]))
                if month < 13 and day < 31:
                    birth = 1
            if len(num) == 11:
                birth = 1
        return birth

    def get_pinyin(self, email_prefix):
        """ #拼音匹配"""

        lst = [info for info in re.split(
            r'\d+', email_prefix) if len(info) > 3]
        pinyin = 1
        if lst == []:
            return pinyin

        if lst:
            email = lst[0]
            pattern = re.compile(
                r'[^aoeiuv]?h?[iuv]?(ai|ei|ao|ou|er|ang?|eng?|ong|a|o|e|i|u|ng|n)?')
            for i in range(0, 4):
                if len(email) == 0:
                    break
                info = pattern.match(email)
                if info.group():
                    email = email.split(info.group())[1]
                    if len(info.group()) == 0:
                        pinyin = 0
                    if len(email) == 1:
                        pinyin = 0
            else:
                pass
        return pinyin

    def is_qq(self, email_prefix):
        """#qq邮箱匹配"""
        if not email_prefix.isdigit():
            return False

        l = len(email_prefix)
        if l <= 4 or l >= 11:
            return False

        if email_prefix[0] == '0':
            return False

        return True

    def get_email(self, fullemail):
        """#邮箱格式匹配"""

        email = str(fullemail).strip()
        if self.email_format_regex.findall(email):
            return True
        else:
            return False

    def get_other_fea(self, email_prefix):
        """"#是否包含特殊字符以及字母数字的组合"""
        hua_fen = 0
        special = 0
        # 以数字为分隔符，查看邮箱的字母数字组合次数是否大于2
        email_lst = [
            info for info in re.split(r'\d+', email_prefix) if len(info) > 0]
        if len(email_lst) > 1:
            hua_fen = 1
        if re.search(r'\w|-|_|—|-|\*|\?|#|.|', email_prefix):
            special = 1  # 包含特殊字符
        return hua_fen, special

    def good_num(self, email_s, email_l):
        num = re.findall(r'1\d{10}', email_s)  # 判断是否是手机号
        good = False
        p1 = re.compile(
            r'(?:(?:0(?=1)|1(?=2)|2(?=3)|3(?=4)|4(?=5)|5(?=6)|6(?=7)|7(?=8)|8(?=9)){3,}|(?:9(?=8)|8(?=7)|7(?=6)|6(?=5)|5(?=4)|4(?=3)|3(?=2)|2(?=1)|1(?=0)){3,})\d')  # 匹配4-9位连续的数字
        p2 = re.compile(r'(\d)\1{2,}')  # 3位以上重复数字
        p3 = re.compile(
            r'(19|20)[\d]{2}(1[0-2]|0?[1-9])(31|2[0-9]|1[0-9]|0?[0-9])')  # 匹配年份
        p4 = re.compile(r'((\d){1,}(\d){1,})\1{1,}')  # 匹配连续重复2次及以上的数据123123型
        if re.search(r'qq|QQ', email_l) or num:  # 判断是否是qq邮箱或者是否是手机号邮箱
            info1 = p1.search(email_s)
            info2 = p2.search(email_s)
            info3 = p3.search(email_s)
            info4 = p4.search(email_s)
            if info1 or info2 or info3 or info4:
                good = True
        return good


class EmailRule(EmailFile, EmailCheks):

    """  邮箱标签：
        "看上去不太正常的邮箱”
        “典型的临时邮箱”
        “很活跃的邮箱”
        “好像是不存在的邮箱”
        “靓号邮箱”
        “古老的邮箱”
        “有点假的过长的邮箱”
        “有点假的太短的邮箱”
    """

    def get_email_result(self, email):
        """"
        获取结果。这部分的分值是我自己定的，分值越大，代表越正常（分值部分我们可以进一步沟通，商量）

        """
        score = 0
        message = []
        if not self.get_email(email):
            return False

        email_split = email.split('@')
        email_postfix = email_split[1]
        email_prefix = email_split[0]

        # if re.search(r'qq|QQ', email_postfix):  # 判断是否为qq邮箱
        #     if self.is_qq(email_prefix):
        #         score = 90
        # else:
        if self.check_word(email_prefix):  # 是否包含英文单词
            score += 5
        if self.check_name(email_prefix):  # 是否包含英文名称
            score += 5
        pinyin = self.get_pinyin(email_prefix)  # 是否包含拼音
        score = score + 2 * pinyin

        num = self.check_num(email_prefix)
        score = score + 2 * num

        sheng, yun = self.get_zimu(email_prefix)
        score = score + 2 * sheng
        score = score + 5 * yun

        huafen, special = self.get_other_fea(email_prefix)
        score = score - 5 * huafen  # 字母数字组合次数较大，越不正常
        score = score + 5 * special

        mc = MailChecker(email, self.providers)
        if mc.is_temp():
            score = 0
            message.append('典型的临时邮箱哟')
            return score, message

        if mc.is_real():
            score += 10
            message.append('真实存在的邮箱哟')
        else:
            score = 0
            message.append('好像是不存在的邮箱哟')
            return score, message

        if self.good_num(email_prefix, email_postfix):
            message.append('靓号邮箱哟')
        if len(email_prefix) > 20:
            message.append('有点假得过长的邮箱')

        if len(email_prefix) < 4 and email_prefix not in ['ad', 'ads', 'job', 'hr', 'm', 'top', 'hi', 'dj']:
            message.append('有点假得太短的邮箱')

        leak = mc.check_leak()
        if leak > 3:
            score += 20
            message.append('有历史痕迹的邮箱哟')
        else:
            message.append('无历史痕迹的邮箱哟')
        reg = mc.check_reg_web()
        if 3 > reg > 0:
            score += 10
            message.append('互联网上活跃的邮箱哟')
        elif reg >= 3:
            score += 30
            message.append('互联网上较活跃的邮箱哟')
        else:
            message.append('互联网上不太活跃的邮箱哟')
        return score, message

if __name__ == "__main__":
    emails = ["shell_chen@yeah.net", "cxx20140126@163.com",
              "cxx520@gmail.com", "tutalex@vip.qq.com"]
    # email = raw_input("please enter your email:")
    er = EmailRule()
    for email in emails:
        score, message = er.get_email_result(email)
        print email, ":", score, message
